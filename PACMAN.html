<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Pacman Simple</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: black;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid #000080;
            background-color: black;
        }
        #score {
            color: white;
            font-size: 24px;
            margin-top: 10px;
        }
        #restartBtn {
            display: none;
            margin-top: 10px;
            padding: 10px 20px;
            font-size: 18px;
            background-color: #000080;
            color: white;
            border: 2px solid #0000FF;
            cursor: pointer;
        }
        #restartBtn:hover {
            background-color: #0000FF;
        }
    </style>
</head>
<body>
    <div>
        <canvas id="gameCanvas" width="600" height="600"></canvas>
        <div id="score">Puntuación: 0</div>
        <button id="restartBtn">Volver a Jugar</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const restartBtn = document.getElementById('restartBtn');

        // Configuración del juego
        const tileSize = 30;
        const rows = 20;
        const cols = 20;

        // Mapa simple (1 = pared, 0 = punto, 3 = power-up, 2 = vacío)
        let map = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1],
            [1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1],
            [1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1],
            [1,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,0,0,1],
            [1,1,1,0,0,0,0,0,1,3,3,1,0,0,0,0,0,1,1,1],
            [1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,1,1,1],
            [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],
            [1,1,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,1,1,1],
            [1,0,0,0,0,0,1,0,0,1,1,0,0,1,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,0,0,1,1,0,0,1,1,0,1,1,0,1],
            [1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
            [1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1],
            [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,0,1,0,1,1,0,1,0,1,1,1,1,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        // Posición inicial de Pacman
        let pacman = { x: 1, y: 1, dir: 'right', mouthOpen: true };

        // Fantasmas (4 fantasmas con posiciones iniciales separadas y colores)
        let ghosts = [
            { x: 9, y: 10, dir: 'up', color: '#FF0000', startX: 9, startY: 10 }, // Rojo
            { x: 10, y: 10, dir: 'down', color: '#FFB8FF', startX: 10, startY: 10 }, // Rosa
            { x: 9, y: 9, dir: 'left', color: '#00FFFF', startX: 9, startY: 9 }, // Cian
            { x: 10, y: 9, dir: 'right', color: '#FFB852', startX: 10, startY: 9 }  // Naranja
        ];

        let score = 0;
        let gameRunning = true;
        let powerMode = false;
        let powerTimer = 0;
        let ghostMoveCounter = 0; // Contador para ralentizar fantasmas

        // Función para reiniciar el juego
        function restartGame() {
            map = [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1],
                [1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1],
                [1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,1],
                [1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1],
                [1,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,0,0,1],
                [1,1,1,0,0,0,0,0,1,3,3,1,0,0,0,0,0,1,1,1],
                [1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,1,1,1],
                [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],
                [1,1,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,1,1,1],
                [1,0,0,0,0,0,1,0,0,1,1,0,0,1,0,0,0,0,0,1],
                [1,0,1,1,0,1,1,0,0,1,1,0,0,1,1,0,1,1,0,1],
                [1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
                [1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1],
                [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,1,0,1,0,1,1,0,1,0,1,1,1,1,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ];
            pacman = { x: 1, y: 1, dir: 'right', mouthOpen: true };
            ghosts = [
                { x: 9, y: 10, dir: 'up', color: '#FF0000', startX: 9, startY: 10 },
                { x: 10, y: 10, dir: 'down', color: '#FFB8FF', startX: 10, startY: 10 },
                { x: 9, y: 9, dir: 'left', color: '#00FFFF', startX: 9, startY: 9 },
                { x: 10, y: 9, dir: 'right', color: '#FFB852', startX: 10, startY: 9 }
            ];
            score = 0;
            gameRunning = true;
            powerMode = false;
            powerTimer = 0;
            ghostMoveCounter = 0;
            scoreElement.textContent = 'Puntuación: ' + score;
            restartBtn.style.display = 'none';
            gameLoop();
        }

        // Evento del botón de reinicio
        restartBtn.addEventListener('click', restartGame);

        // Dibujar el mapa
        function drawMap() {
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = col * tileSize;
                    const y = row * tileSize;
                    if (map[row][col] === 1) {
                        ctx.fillStyle = '#000080';
                        ctx.fillRect(x, y, tileSize, tileSize);
                        ctx.strokeStyle = '#0000FF';
                        ctx.strokeRect(x, y, tileSize, tileSize);
                    } else if (map[row][col] === 0) {
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(x, y, tileSize, tileSize);
                        ctx.fillStyle = '#FFFF00';
                        ctx.beginPath();
                        ctx.arc(x + tileSize/2, y + tileSize/2, 3, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (map[row][col] === 3) {
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(x, y, tileSize, tileSize);
                        ctx.fillStyle = '#FFFF00';
                        ctx.beginPath();
                        ctx.arc(x + tileSize/2, y + tileSize/2, 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        // Dibujar Pacman
        function drawPacman() {
            const x = pacman.x * tileSize + tileSize / 2;
            const y = pacman.y * tileSize + tileSize / 2;
            ctx.fillStyle = '#FFFF00';
            ctx.beginPath();
            let startAngle, endAngle;
            if (pacman.dir === 'right') {
                startAngle = pacman.mouthOpen ? 0.2 * Math.PI : 0;
                endAngle = pacman.mouthOpen ? 1.8 * Math.PI : 2 * Math.PI;
            } else if (pacman.dir === 'left') {
                startAngle = pacman.mouthOpen ? 1.2 * Math.PI : Math.PI;
                endAngle = pacman.mouthOpen ? 0.8 * Math.PI : Math.PI;
            } else if (pacman.dir === 'up') {
                startAngle = pacman.mouthOpen ? 1.7 * Math.PI : 1.5 * Math.PI;
                endAngle = pacman.mouthOpen ? 1.3 * Math.PI : 0.5 * Math.PI;
            } else if (pacman.dir === 'down') {
                startAngle = pacman.mouthOpen ? 0.7 * Math.PI : 0.5 * Math.PI;
                endAngle = pacman.mouthOpen ? 0.3 * Math.PI : 1.5 * Math.PI;
            }
            ctx.arc(x, y, tileSize / 2 - 2, startAngle, endAngle);
            ctx.lineTo(x, y);
            ctx.fill();
        }

        // Dibujar fantasmas
        function drawGhosts() {
            ghosts.forEach(ghost => {
                const x = ghost.x * tileSize + tileSize / 2;
                const y = ghost.y * tileSize + tileSize / 2;
                const ghostColor = powerMode ? '#0000FF' : ghost.color;
                ctx.fillStyle = ghostColor;
                ctx.beginPath();
                ctx.arc(x, y, tileSize / 2 - 2, Math.PI, 0);
                ctx.lineTo(x + tileSize / 2, y + tileSize / 2);
                ctx.lineTo(x + tileSize / 6, y + tileSize / 3);
                ctx.lineTo(x, y + tileSize / 2);
                ctx.lineTo(x - tileSize / 6, y + tileSize / 3);
                ctx.lineTo(x - tileSize / 2, y + tileSize / 2);
                ctx.lineTo(x - tileSize / 2, y);
                ctx.fill();
                // Ojos
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(x - tileSize / 6, y - tileSize / 6, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x + tileSize / 6, y - tileSize / 6, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = powerMode ? 'white' : 'black';
                ctx.beginPath();
                ctx.arc(x - tileSize / 6, y - tileSize / 6, 1, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x + tileSize / 6, y - tileSize / 6, 1, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Mover Pacman
        function movePacman(newX, newY) {
            if (newX >= 0 && newX < cols && newY >= 0 && newY < rows && map[newY][newX] !== 1) {
                if (map[newY][newX] === 0) {
                    map[newY][newX] = 2; // Consumir punto
                    score += 10;
                } else if (map[newY][newX] === 3) {
                    map[newY][newX] = 2; // Consumir power-up
                    score += 50;
                    powerMode = true;
                    powerTimer = Date.now() + 10000; // 10 segundos
                }
                pacman.x = newX;
                pacman.y = newY;
                scoreElement.textContent = 'Puntuación: ' + score;
            }
        }

        // Movimiento de teclas
        document.addEventListener('keydown', (e) => {
            if (!gameRunning) return;
            let newX = pacman.x;
            let newY = pacman.y;
            switch(e.key) {
                case 'ArrowRight':
                    newX++;
                    pacman.dir = 'right';
                    break;
                case 'ArrowLeft':
                    newX--;
                    pacman.dir = 'left';
                    break;
                case 'ArrowUp':
                    newY--;
                    pacman.dir = 'up';
                    break;
                case 'ArrowDown':
                    newY++;
                    pacman.dir = 'down';
                    break;
            }
            movePacman(newX, newY);
        });

        // Movimiento simple de fantasmas (IA básica: mover aleatoriamente, independientes, más lento)
        function moveGhosts() {
            ghostMoveCounter++;
            if (ghostMoveCounter >= 30) { // Mover cada 30 frames (~0.5 seg a 60fps)
                ghostMoveCounter = 0;
                ghosts.forEach(ghost => {
                    const directions = [
                        { dx: 0, dy: -1, dir: 'up' },
                        { dx: 0, dy: 1, dir: 'down' },
                        { dx: -1, dy: 0, dir: 'left' },
                        { dx: 1, dy: 0, dir: 'right' }
                    ];
                    const validDirs = directions.filter(d => {
                        const nx = ghost.x + d.dx;
                        const ny = ghost.y + d.dy;
                        return nx >= 0 && nx < cols && ny >= 0 && ny < rows && map[ny][nx] !== 1;
                    });
                    if (validDirs.length > 0) {
                        const randomDir = validDirs[Math.floor(Math.random() * validDirs.length)];
                        ghost.x += randomDir.dx;
                        ghost.y += randomDir.dy;
                        ghost.dir = randomDir.dir;
                    }
                    // Colisión con Pacman
                    if (ghost.x === pacman.x && ghost.y === pacman.y) {
                        if (powerMode) {
                            // Comer fantasma
                            score += 200;
                            scoreElement.textContent = 'Puntuación: ' + score;
                            // Respawnear fantasma
                            ghost.x = ghost.startX;
                            ghost.y = ghost.startY;
                        } else {
                            // Game over
                            gameRunning = false;
                            restartBtn.style.display = 'block';
                        }
                    }
                });
            }
        }

        // Animación
        function gameLoop() {
            // Verificar power mode
            if (powerMode && Date.now() > powerTimer) {
                powerMode = false;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMap();
            drawPacman();
            drawGhosts();
            pacman.mouthOpen = !pacman.mouthOpen;
            if (gameRunning) {
                moveGhosts();
                requestAnimationFrame(gameLoop);
            }
        }

        // Verificar si ganó (todos los puntos y power-ups consumidos)
        function checkWin() {
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (map[row][col] === 0 || map[row][col] === 3) return false;
                }
            }
            gameRunning = false;
            restartBtn.style.display = 'block';
            return true;
        }

        // Iniciar juego
        gameLoop();
        setInterval(() => {
            if (gameRunning) checkWin();
        }, 1000); // Verificar victoria cada segundo
    </script>
    <!-- Agrega este snippet al final de cada archivo HTML de juego, justo antes de </body> -->
<!-- No modifica la lógica del juego, solo añade un botón fijo en la esquina inferior derecha -->
<div style="position: fixed; bottom: 20px; right: 20px; z-index: 9999;">
    <a href="MENU.html" style="background: linear-gradient(45deg, #00c6ff, #0072ff); color: white; border: none; padding: 12px 18px; border-radius: 25px; cursor: pointer; font-size: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); text-decoration: none; font-weight: bold;">🏠 Volver al Menú</a>
</div>
</body>
</html>